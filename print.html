<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Rust with Actix, WASM &amp; Giphy</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="nice-features-option.html"><strong aria-hidden="true">1.</strong> Nice Features: Option</a></li><li class="chapter-item expanded "><a href="nice-features-result.html"><strong aria-hidden="true">2.</strong> Nice Features: Result</a></li><li class="chapter-item expanded "><a href="nice-features-tgm.html"><strong aria-hidden="true">3.</strong> Nice Features: Traits, Generics &amp; MetaProgramming</a></li><li class="chapter-item expanded "><a href="build-the-app.html"><strong aria-hidden="true">4.</strong> Build the App</a></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">5.</strong> Bonus: Ownership, Borrowing &amp; Lifetimes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Learning Rust with Actix, WASM &amp; Giphy</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#learning-rust-with-actix-wasm--giphy" id="learning-rust-with-actix-wasm--giphy">Learning Rust with Actix, WASM &amp; Giphy</a></h1>
<p>Let's learn a little bit about Rust with a demo WebAssembly (WASM) application that allows a user to search for and save animated GIFs to a user profile using the <a href="https://developers.giphy.com/docs/">GIPHY API</a>.</p>
<p>The API is structured as a very simple JSON RPC API built using <a href="https://actix.rs/">actix.rs</a>. The client &amp; server use the same exact data models (the same library code) for communicating over the network. All interaction is protected by JWT authN/authZ.</p>
<p>The client is a WASM application built using Rust &amp; the <a href="https://seed-rs.org">Seed framework</a>.</p>
<p>We are using Postgres for data storage &amp; <a href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> for the interface.</p>
<p>Check out the repository at <a href="https://github.com/thedodd/giphy-api/">github.com/thedodd/giphy-api</a>.</p>
<h3><a class="header" href="#learning-objectives" id="learning-objectives">Learning Objectives</a></h3>
<p>First and foremost, let's learn something new about Rust!</p>
<ol>
<li><strong>Review some nice language features.</strong> Let's just start off with a quick sampling of various language features which I love! There are a few chapters dedicated to these features.</li>
<li><strong>Build the app!</strong> We have a working application to study, so let's build it. This will give us some practice with the Rust toolchain.</li>
<li><strong>Bonus:</strong> Let's dive into Ownership, Borrowing &amp; Lifetimes, the &quot;hard parts&quot; of Rust.</li>
</ol>
<h1><a class="header" href="#nice-features-option" id="nice-features-option">Nice Features: Option</a></h1>
<p>Instead of <code>nil</code>, <code>None</code>, or <code>Null</code>, in Rust we have the <code>Option</code> enum type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>An example of how we are using an <code>Option</code> type in our app code.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// A GIF from the Giphy API which has been saved by a user.
struct SavedGif {
    /// Object ID.
    pub id: i64,
    /// The ID of the user which has saved this GIF.
    pub user: i64,
    /// The ID of this GIF in the Giphy system.
    pub giphy_id: String,
    /// The title of the GIF.
    pub title: String,
    /// The URL of the GIF.
    pub url: String,
    /// The category given to this GIF by the user.
    pub category: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>How might we use this?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Take the inner value, or a default.
gif.category.unwrap_or_default();

// Take the inner value, or an explicit alternative.
gif.category.unwrap_or(String::from(&quot;Woo!&quot;));
gif.category.unwrap_or_else(|| String::from(&quot;Woo!&quot;)); // Using a closure.

// Match on the structure of the option itself.
// This matches against the possible variants of the type.
match gif.category {
    Some(val) =&gt; val,
    None =&gt; String::from(&quot;New Val&quot;),
}

// If we just want to check for Some(..) or None.
if let Some(val) = gif.category {
    // Use the inner value here.
}
if let None = gif.category {
    // No category, so do something else.
}
<span class="boring">}
</span></code></pre></pre>
<p>Why is this great? No more nil pointer dereferencing.</p>
<p>What about our own custom enum types? Here is one that we use heavily in the app.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// An API response.
enum Response&lt;D&gt; {
    /// A success payload with data.
    Data(D),
    /// An error payload with an error.
    Error(Error),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#nice-features-result" id="nice-features-result">Nice Features: Result</a></h1>
<p>Instead of <code>except Exception as ex</code> or <code>if err != nil</code> or <code>rescue ExceptionType</code> or <code>try .. catch</code> or (the worst) <code>if ret &lt; 0</code>, in Rust we have another enum type: <code>Result</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// An enum, generic over a success type and an error type.
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, so how do we use a result? Here is an example from our app (slightly abridged).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Our error struct.
struct Error {/* ... */}

fn from_jwt(/* ... */) -&gt; Result&lt;Claims, Error&gt;
    // ... snip ...
    let claims = // Decode a token into our `Claims` structure.
    claims.must_not_be_expired()?;
    // ... snip ...
}
<span class="boring">}
</span></code></pre></pre>
<p>That <code>claims.must_not_be_expired()</code> call returns a <code>Result</code>. If an error comes up, Rust has a dedicated syntax element — the postfix <code>?</code> operator — to perform an &quot;early return&quot; when a <code>Result::Err(..)</code> is encountered.</p>
<p>What's more? Rust performs automatic type coercion with the <code>?</code> operator. What does this mean?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The std From trait.
trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>How is this used?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Let's say `must_not_be_expired()` returns a different error type:
fn must_not_be_expired(&amp;self) -&gt; Result&lt;(), ExpirationError&gt; {/*...*/}

impl From&lt;ExpirationError&gt; for Error {
    fn from(src: ExpirationError) -&gt; Error {
        Error{
            // Use the values from src here.
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So, when we suffix <code>claims.must_not_be_expired()</code> with a <code>?</code>, in this context Rust will automatically use the <code>From</code> impl we have above to convert the type for us.</p>
<p>Using Rust's <code>match</code> syntax for structural matching also works as expected with results.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>match my_result {
    Ok(data) =&gt; data,
    Err(err) =&gt; {
        // Trace the error ... log the error ... transform the error ... whatever.
        tracing::error!(&quot;{}&quot;, err);
        return Err(err);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lots of methods are available on the <code>Result</code> type as well.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Result::Ok(0)
    .map(|val| val + 1)
    // Let's change the error type if one is encountered.
    .map_err(|_err| &quot;something bad happened!&quot;)
    .and_then(|val| {
        if val &gt; 0 {
            Ok(val)
        } else {
            Err(&quot;not good!!!&quot;)
        }
    })
<span class="boring">}
</span></code></pre></pre>
<p>The Rust standard syntax prelude includes the discriminants of the Result type for direct use, as seen above. So you can directly use <code>Ok(..)</code> &amp; <code>Err(..)</code> in your code as a shorthand. Rust will infer the appropriate types based on function signatures and the like.</p>
<h1><a class="header" href="#nice-features-traits-generics--metaprogramming" id="nice-features-traits-generics--metaprogramming">Nice Features: Traits, Generics &amp; MetaProgramming</a></h1>
<h3><a class="header" href="#traits" id="traits">Traits</a></h3>
<p>Some languages have Interfaces, some languages have Protocols, Rust was trying really hard to be the cool kid, so it has Traits instead.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Worker {
    fn do_work(&amp;self) -&gt; Result&lt;(), Error&gt;;
}

struct ThreadedWorker;

impl Worker for ThreadedWorker {
    fn do_work(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Err(Error::default()) // FAIL!
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait inheritence is also supported. <code>trait Worker: Awesome + Cool + Nifty {..}</code> requires that any implementor of the <code>Worker</code> trait must also implement <code>Awesome</code>, <code>Cool</code>, and <code>Nifty</code>.</p>
<h3><a class="header" href="#generics" id="generics">Generics</a></h3>
<p>The enums we've studied so far (Option &amp; Result) are both generic types. Here is a generic type of our own which we use in this app.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// An API response.
enum Response&lt;D&gt; {
    /// A success payload with data.
    Data(D),
    /// An error payload with an error.
    Error(Error),
}
<span class="boring">}
</span></code></pre></pre>
<p>Our response struct carries a data payload within its <code>Data</code> variant, and an error in its <code>Error</code> variant. At this point, we can use any type for <code>D</code>.</p>
<p>Often times we don't actually want to allow any lowsy old type to be used though. How do constraint which types can be used?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// We can constrain inline.
fn ddos_attack&lt;T: HttpEndpoint&gt;(target: T) {..}

// Or we can constrain with a `where` clause,
// which is nice when you have lots of constraints.
fn ddos_attack&lt;T, C&gt;(target: T, ctx: C)
    where
        T: HttpEndpoint,
        C: Context + Send + Sync,
{..}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#metaprogramming" id="metaprogramming">MetaProgramming</a></h3>
<p>There are a few kinds in Rust, here is one you will use ALL THE TIME.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// An API response.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag=&quot;result&quot;, content=&quot;payload&quot;)]
enum Response&lt;D&gt; {
    /// A success payload with data.
    #[serde(rename=&quot;data&quot;)]
    Data(D),
    /// An error payload with an error.
    #[serde(rename=&quot;error&quot;)]
    Error(Error),
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the <code>#[derive(Serialize)]</code> attribute (focusing only on <code>Serialize</code> for now), invokes a function <strong>at compile-type</strong> which will run Rust code over the AST of this enum and generate more code. In this case, in generates code to allow this enum to be serialized into various data formats (JSON, YAML, &amp;c). These are called &quot;procedural macros&quot;.</p>
<p>The <code>#[serde(..)]</code> attribute is a &quot;helper attribute&quot; of the Serialize &amp; Deserialize macros defined in the serde library code itself, and modifies the macro's behavior.</p>
<h1><a class="header" href="#build-the-app" id="build-the-app">Build the App</a></h1>
<p>First, you'll need Rust. Head on over to <a href="https://rustup.rs/">rustup.rs</a> and follow the instructions there to setup the Rust toolchain. After that, let's also add the needed compiler target for the WASM instruction set:</p>
<pre><code class="language-bash"># Add the WASM 32-bit instruction set as a compilation target.
rustup target add wasm32-unknown-unknown
# While we're at it, let's install the wasm-bindgen-cli
# which we will need for our WASM builds.
cargo install wasm-bindgen-cli --version=0.2.55
</code></pre>
<p>Second, you'll need to have docker in place to run the Postgres database, check out the <a href="https://docs.docker.com/get-docker/">docker installation docs</a> if you don't already have docker on your machine.</p>
<p>Now that you have all of the tools in place, let's bring up the DB and build our Rust code.</p>
<pre><code class="language-bash"># Boot Postgres. This will also initialize our tables.
docker run -d --name postgres \
    -e POSTGRES_PASSWORD=pgpass -p 54321:5432 \
    -v `pwd`/pg.sql:/docker-entrypoint-initdb.d/pg.sql \
    postgres
# Build the UI.
cargo build -p client --release --target wasm32-unknown-unknown
# Run wasm-bindgen on our output WASM.
wasm-bindgen target/wasm32-unknown-unknown/release/client.wasm --no-modules --out-dir ./static
# Now, we run our API which will also serve our WASM bundle, HTML and other assets.
source .env # Needed env vars.
cargo run -p server --release
</code></pre>
<p>Now you're ready to start using the app. Simply navigate to <a href="http://localhost:9000">localhost:9000</a> to get started.</p>
<h1><a class="header" href="#bonus-ownership-borrowing--lifetimes" id="bonus-ownership-borrowing--lifetimes">Bonus: Ownership, Borrowing &amp; Lifetimes</a></h1>
<h3><a class="header" href="#data-ownership" id="data-ownership">Data Ownership</a></h3>
<p>Data is always owned. References are a way to lease out access to the owned data, and lifetimes help you (and the compiler) to keep track of this lease.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// The application state object.
#[derive(Clone)]
pub struct State {
    pub db: PgPool,
    pub client: Client,
    pub config: Arc&lt;Config&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's have a look at our API code and how we lease out access to our config data (see <code>server/src/api.rs</code>).</p>
<h3><a class="header" href="#embedding-a-lifetime" id="embedding-a-lifetime">Embedding a Lifetime</a></h3>
<p>Remember that with references, you are dealing with data that is owned by something else.</p>
<pre><pre class="playpen"><code class="language-rust">struct DBInfo&lt;'a&gt; {
    name: &amp;'a str,
    tables: u64,
}

fn build_info&lt;'a&gt;(name: &amp;'a str, db: &amp;mut PgConn) -&gt; DBInfo&lt;'a&gt; {
    // Do some work, get some info.
    let tables = get_table_count(db);
    DBInfo{name, tables}
}

fn main() {
    let my_db_name = String::from(&quot;oxidize&quot;);

    // Build our info struct.
    let info = build_info(&amp;my_db_name, get_db());

    // Report our info.
    metrics.report_info(info); // &lt;-- the lifetime 'a is still alive here.

    // ... do more cool stuff.
}
</code></pre></pre>
<p>Why is this significant?</p>
<ul>
<li>Your code doesn't have to check to see if <code>info.name</code> is nil/null/void ... because that doesn't exist in Rust.</li>
<li>For as long as <code>'a</code> is alive and well, that reference to <code>my_db_name</code> stands. Can not be mutated. Can not be destroyed.</li>
<li>No garbage collector needed.</li>
</ul>
<p>Remember, lifetime rules apply to <code>&amp;</code> references. Not to the various pointer types in Rust (Box, Rc, Arc etc), though you could still pass around references to them if needed.</p>
<h3><a class="header" href="#mutability--exclusive-references" id="mutability--exclusive-references">Mutability &amp; Exclusive References</a></h3>
<p>In Rust, we have references <code>&amp;</code> (shared) and we have mutable references <code>&amp;mut</code> (exclusive).</p>
<p>This, combined with Rust's lifetime system, ensures that we don't have pointers retained in random parts of our app which might be making subtle changes to values behind the scenes.</p>
<p>Let's look at <code>client/src/state.rs</code> for some examples on handling mutability.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
